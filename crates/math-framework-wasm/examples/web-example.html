<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Math Framework WASM - Web Example</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        h1 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 10px; }
        h2 { color: #34495e; margin-top: 30px; }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        input, button {
            padding: 10px;
            font-size: 16px;
            margin: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        button {
            background: #3498db;
            color: white;
            cursor: pointer;
            border: none;
        }
        button:hover { background: #2980b9; }
        .output {
            background: #ecf0f1;
            padding: 15px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            margin-top: 10px;
            max-height: 300px;
            overflow-y: auto;
        }
        .controls { margin: 10px 0; }
        canvas {
            border: 1px solid #ddd;
            border-radius: 4px;
            background: white;
        }
        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
        }
    </style>
</head>
<body>
    <h1>ðŸ§® Math Framework WASM - Interactive Demo</h1>

    <div class="grid">
        <!-- Fibonacci Calculator -->
        <div class="container">
            <h2>Fibonacci Calculator</h2>
            <div class="controls">
                <input type="number" id="fibInput" value="100" min="0" max="10000">
                <button onclick="calculateFibonacci()">Calculate F(n)</button>
            </div>
            <div class="output" id="fibOutput"></div>
        </div>

        <!-- Zeckendorf Decomposition -->
        <div class="container">
            <h2>Zeckendorf Decomposition</h2>
            <div class="controls">
                <input type="number" id="zeckInput" value="100" min="1" max="1000000">
                <button onclick="calculateZeckendorf()">Decompose</button>
            </div>
            <div class="output" id="zeckOutput"></div>
        </div>

        <!-- BK Divergence -->
        <div class="container">
            <h2>BK Divergence (V, U, S)</h2>
            <div class="controls">
                <input type="number" id="bkInput" value="20" min="1" max="1000">
                <button onclick="calculateBKDivergence()">Calculate</button>
            </div>
            <div class="output" id="bkOutput"></div>
        </div>
    </div>

    <!-- Phase Space Visualization -->
    <div class="container">
        <h2>Phase Space Trajectory</h2>
        <div class="controls">
            <label>Range: <input type="number" id="rangeStart" value="1" min="1" max="100"></label>
            <label>to <input type="number" id="rangeEnd" value="50" min="1" max="100"></label>
            <button onclick="visualizeTrajectory()">Visualize</button>
        </div>
        <canvas id="trajectoryCanvas" width="1160" height="400"></canvas>
    </div>

    <!-- Performance Benchmark -->
    <div class="container">
        <h2>âš¡ Performance Benchmark</h2>
        <button onclick="runBenchmark()">Run Benchmark</button>
        <div class="output" id="benchmarkOutput"></div>
    </div>

    <script type="module">
        // Import WASM module (adjust path based on your build)
        import init, * as wasm from '../pkg-web/math_framework_wasm.js';

        // Initialize WASM
        await init();
        window.wasm = wasm;

        console.log('âœ… WASM initialized! Version:', wasm.version());

        // Fibonacci Calculator
        window.calculateFibonacci = function() {
            const n = parseInt(document.getElementById('fibInput').value);
            const output = document.getElementById('fibOutput');

            try {
                const start = performance.now();
                const result = wasm.fibonacci(BigInt(n));
                const time = (performance.now() - start).toFixed(2);

                output.textContent = `F(${n}) = ${result}\n\n`;
                output.textContent += `Digits: ${result.length}\n`;
                output.textContent += `Computed in: ${time}ms\n\n`;

                // Also compute Lucas
                const lucas = wasm.lucas(n);
                output.textContent += `L(${n}) = ${lucas}`;

                // Golden ratio
                if (n > 0) {
                    const phi = wasm.golden_ratio(n);
                    output.textContent += `\n\nÏ† approximation: ${phi.toFixed(15)}`;
                }
            } catch (e) {
                output.textContent = `Error: ${e}`;
            }
        };

        // Zeckendorf Decomposition
        window.calculateZeckendorf = function() {
            const n = parseInt(document.getElementById('zeckInput').value);
            const output = document.getElementById('zeckOutput');

            try {
                const start = performance.now();
                const z = wasm.zeckendorf(n);
                const time = (performance.now() - start).toFixed(2);

                output.textContent = `Zeckendorf(${n}):\n\n`;
                output.textContent += `Representation: ${z.toString()}\n\n`;
                output.textContent += `Indices: ${z.indices}\n\n`;
                output.textContent += `Binary: ${wasm.zeckendorf_to_binary(z)}\n\n`;
                output.textContent += `Fibonacci weight: ${wasm.fibonacci_weight(n)}\n`;
                output.textContent += `Is Fibonacci? ${wasm.is_fibonacci(n)}\n\n`;
                output.textContent += `Valid? ${z.isValid()}\n`;
                output.textContent += `Computed in: ${time}ms`;
            } catch (e) {
                output.textContent = `Error: ${e}`;
            }
        };

        // BK Divergence
        window.calculateBKDivergence = function() {
            const n = parseInt(document.getElementById('bkInput').value);
            const output = document.getElementById('bkOutput');

            try {
                const start = performance.now();
                let result = 'n    V      U        S\n';
                result += '-'.repeat(30) + '\n';

                for (let i = 1; i <= n; i++) {
                    const v = wasm.bk_v(i);
                    const u = wasm.bk_u(i);
                    const s = wasm.bk_divergence(i);
                    result += `${i.toString().padStart(2)}   ${v.toString().padStart(3)}   ${u.toString().padStart(5)}   ${s.toString().padStart(7)}\n`;
                }

                const time = (performance.now() - start).toFixed(2);
                result += `\nComputed in: ${time}ms`;

                output.textContent = result;
            } catch (e) {
                output.textContent = `Error: ${e}`;
            }
        };

        // Visualize Trajectory
        window.visualizeTrajectory = function() {
            const start = parseInt(document.getElementById('rangeStart').value);
            const end = parseInt(document.getElementById('rangeEnd').value);

            const canvas = document.getElementById('trajectoryCanvas');
            const ctx = canvas.getContext('2d');

            // Clear canvas
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            try {
                const trajectory = new wasm.WasmTrajectory(start, end);

                // Get all points
                const points = [];
                for (let i = 0; i < trajectory.length; i++) {
                    const point = trajectory.getPoint(i);
                    points.push({ n: point.n, x: point.x, y: point.y, z: point.z });
                }

                // Find min/max for scaling
                const minX = Math.min(...points.map(p => p.x));
                const maxX = Math.max(...points.map(p => p.x));
                const minY = Math.min(...points.map(p => p.y));
                const maxY = Math.max(...points.map(p => p.y));

                const margin = 40;
                const scaleX = (canvas.width - 2 * margin) / (maxX - minX || 1);
                const scaleY = (canvas.height - 2 * margin) / (maxY - minY || 1);

                // Draw axes
                ctx.strokeStyle = '#ddd';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(margin, margin);
                ctx.lineTo(margin, canvas.height - margin);
                ctx.lineTo(canvas.width - margin, canvas.height - margin);
                ctx.stroke();

                // Draw trajectory
                ctx.strokeStyle = '#3498db';
                ctx.lineWidth = 2;
                ctx.beginPath();

                for (let i = 0; i < points.length; i++) {
                    const x = margin + (points[i].x - minX) * scaleX;
                    const y = canvas.height - margin - (points[i].y - minY) * scaleY;

                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();

                // Draw points
                ctx.fillStyle = '#e74c3c';
                for (let i = 0; i < points.length; i++) {
                    const x = margin + (points[i].x - minX) * scaleX;
                    const y = canvas.height - margin - (points[i].y - minY) * scaleY;

                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, 2 * Math.PI);
                    ctx.fill();
                }

                // Labels
                ctx.fillStyle = 'black';
                ctx.font = '12px sans-serif';
                ctx.fillText('V (log scale)', margin, 20);
                ctx.save();
                ctx.translate(15, canvas.height / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillText('U (log scale)', 0, 0);
                ctx.restore();

            } catch (e) {
                console.error('Visualization error:', e);
            }
        };

        // Benchmark
        window.runBenchmark = function() {
            const output = document.getElementById('benchmarkOutput');
            output.textContent = 'Running benchmarks...\n\n';

            setTimeout(() => {
                let result = '';

                // Fibonacci benchmark
                let start = performance.now();
                wasm.fibonacci(1000n);
                let time = (performance.now() - start).toFixed(2);
                result += `F(1000): ${time}ms\n`;

                // Zeckendorf benchmark
                start = performance.now();
                wasm.zeckendorf(1000000);
                time = (performance.now() - start).toFixed(2);
                result += `Zeckendorf(1000000): ${time}ms\n`;

                // BK divergence benchmark
                start = performance.now();
                wasm.bk_divergence(1000);
                time = (performance.now() - start).toFixed(2);
                result += `S(1000): ${time}ms\n`;

                // Trajectory benchmark
                start = performance.now();
                const traj = new wasm.WasmTrajectory(1, 100);
                time = (performance.now() - start).toFixed(2);
                result += `Trajectory(1-100): ${time}ms\n`;

                result += '\nâœ… All benchmarks complete!';
                output.textContent = result;
            }, 100);
        };

        // Auto-run initial calculations
        calculateFibonacci();
        calculateZeckendorf();
        calculateBKDivergence();
        visualizeTrajectory();
    </script>
</body>
</html>
